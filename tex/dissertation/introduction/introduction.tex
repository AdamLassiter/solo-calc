\subsection{Motivation, Landscape and Current Problem}
    As computer processor clock speeds have begun to stagnate in performance increase per year, manufacturers have begun to shift focus to multiple cores in search of greater performance.
    Supercomputers for decades have operated around the idea of clusters and massive parallelism.
    For this reason there is now more than ever a need to study the effects of parallelism in computation and to be able to effectively model concurrent communicating systems as they start to become commonplace in all computational applications.


\subsection{Scope and Relevance of Research}
    The following aims to provide a visualisation of the parallel computation of multiple processes within the context of a concurrency calculus.
    This will be divided into several modular parts that apart demonstrate some challenges on successful implementation, but together fit together to form what should prove to be a useful proof-of-concept tool to aid in understanding of calculi of communicating processes.\\

    In particular, the project tackles the details of implementation of a computational calculus of communicating mobile processes.
    This implementation is then further extended to provide an interactive visualisation of computations to aid in the understanding of how such calculi operate.
    As discussed later in~\ref{subsec:pi-calculus}, the project aims to provide an improvement over the $\pi$-calculus described by~\cite{pi-calculus}, while still remaining functionally equivalent.


\subsection{Overview of Dissertation Structure}
    The first section details an in-depth review of the surrounding literature and current state of the art.
    This includes an examination of various computational calculi, both concurrent and not, and an evaluation of their effectiveness for their given use-cases.
    Included also are some short examples to give a feel of how each calculus is used.\\

    Afterwards follows a short investigation on technologies planned to be used in this project and justifications as to why each was chosen.\\

    Following that is then a breakdown of the development process, description of some simple algorithms involved and the pitfalls which may not be immediately obvious.
    This section attempts to show both the initial and final forms of the project and what difficulties caused this evolution.\\

    Finally, a short conclusion of effectiveness of the design choices made and how a similar project could be conducted differently.\\
