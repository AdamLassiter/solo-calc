\subsection{Read-Eval-Print-Loop Implementation}
    \subsubsection{Analysis}
        A simple REPL interface was constructed to interact with the code written in~\ref{ssec:calculus-implementation}.
        This was done using extended regular expressions\footnotemark~similar to those found in the Perl programming language.
        For each agent, there was an extended regex matching its string representation, with backreferences to extract the necessary data.
        Each of $(?P\langl name \rangl \textit{expression})$ represents a named backreference to the given expression and $(? \, \& rec)$ is a recursive call to the outer $(?\langl rec \rangl \textit{expression})$ expression.
        \footnotetext{These do not meet the normal definitions of regular expressions as they additionally support recursive matches, backreferences and various other syntactic additions that make them context-free grammars rather than regular expressions.}
        
        \begin{definition}{(Solo Matching)\\}
            Solos are built using the regex as follows:
            \begin{align*}
                u \, \tilde{x}       & \quad \longleftarrow \quad \backslash s? (?P \langl subject \rangl [a-z \, 0-9]+) \backslash s (?P \langl objects \rangl ([a-z \, 0-9]+ \backslash s?)+) \backslash s? \\
                \bar{u} \, \tilde{x} & \quad \longleftarrow \quad \backslash s? \backslash ^{\wedge} (?P \langl subject \rangl [a-z \, 0-9]+) \backslash s (?P \langl objects \rangl ([a-z \, 0-9]+ \backslash s?)+) \backslash s?
            \end{align*}
            where a valid name is any lowercase alphanumeric word and $\bar{u}$ is inputted as \texttt{$^{\wedge}$u} and each of \texttt{subject} and \texttt{objects} represent the subject and objects of the solo respectively.
        \end{definition}

        \begin{definition}{(Replication)\\}
            Replicators are built using the regex as follows:
            \begin{align*}
                ! P \quad \longleftarrow \quad \backslash s? \; !(?P \langl agent \rangl.*)\backslash s?
            \end{align*}
            where \texttt{agent} represents $P$ for the expression $!P$.
            It should be noted that this expression must match the whole string, as the trailing $)$ intends to match the end of the expression.
        \end{definition}

        \begin{definition}{(Scope)\\}
            Scopes are built using the regex as follows:
            \begin{align*}
                (x)P \quad \longleftarrow \quad \backslash s? \backslash ((?P \langl bindings \rangl([a-z \, 0-9]+ \backslash s?)+)\backslash )(?P\langl agent \rangl[^{\wedge}\backslash s].+)\backslash s?
            \end{align*}
            where each of \texttt{bindings} and \texttt{agent} represent $x$ and $P$ respectively for the expression $(x) P$.
        \end{definition}

        \begin{definition}{(Composition)\\}
            Compositions are build using the recursive regex as follows:
            \begin{align*}
                (P_1 | \ldots | P_n) \quad \longleftarrow \quad & \backslash s? \backslash (?\langl agents\rangl~\texttt{R}+) (\backslash | (?\&agents))?)\backslash )\backslash s? \\
                \text{where } \texttt{R} \quad \defeq \quad & (?\langl agent\rangl([^{\wedge}|()] | (?\langl rec\rangl\backslash ((?:[^{\wedge}()]++|(?\&rec))*\backslash )))
            \end{align*}
            where each \texttt{agent} is collected in \texttt{agents} and represents each of $P_1 \ldots P_n$.
            It is accepted that this is difficult to read and would benefit from a better-structured parsing system.
            However, for this project and as a write-once solution, it is suitable enough.
        \end{definition}


    \subsubsection{Testing and Correctness}
    \subsubsection{Discussion}
